<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[]]></title>
  <link href="https://lorch.github.io/atom.xml" rel="self"/>
  <link href="https://lorch.github.io/"/>
  <updated>2016-10-17T23:06:07+08:00</updated>
  <id>https://lorch.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[初涉GoLang之编程环境篇]]></title>
    <link href="https://lorch.github.io/14767164878672.html"/>
    <updated>2016-10-17T23:01:27+08:00</updated>
    <id>https://lorch.github.io/14767164878672.html</id>
    <content type="html"><![CDATA[
<p>工欲善其事，必先利其器。所以Golang部署，是我的第一篇纪录.</p>

<blockquote>
<p>部署环境：sublime2 ＋ mac</p>
</blockquote>

<h2 id="toc_0">下载Golang并安装</h2>

<ul>
<li>golang下载地址：<a href="http://golang.org/doc/install">戳我，我是地址君</a></li>
<li>选择对应的版本，这里我选的是：<code>go1.4.2.darwin-amd64-osx10.8.pkg</code></li>
<li>双击下载包，安装</li>
</ul>

<h2 id="toc_1">部署GoLang环境变量</h2>

<p>在mac中，打开iTerm输入 <code>vim ./bash_profig</code>，添加如下路径：</p>

<pre><code class="language-bash">⚠ 这是mac默认安装的所选择的路径，其他系统按照不同的安装路径,将GOROOT设置为不同值*
export GOROOT=/usr/local/Cellar/go/1.4/libexec/
export GOBIN=$GOROOT/bin
⚠ GOPATH有点儿特殊，是一个工作空间，一般一个GoLang应用有一个工作空间，多个路径之间的用:[mac,linux]连接[windows用; 这个跟path环境变量的多个链接相同]。 
export GOPATH=/Users/YourGoPath
export PATH=$PATH:$GOBIN:$GOPATH
</code></pre>

<p>现在，在iTerm输入 <code>go version</code>, 应该可以看到Go的版本号的输出了。</p>

<h2 id="toc_2">配置sublime2上的Golang编写环境</h2>

<p>可以编译Go的编辑器有很多，IiteIDE， Goclipse，Vim， Emacs之类的都行，万能的Vim配好了其实也很好用，是大神利器。此外，个人感觉安装最便利的是Goclipse，使用最便利的是IiteIDE，毕竟这个是专为GoLang设计的忠犬，Emacs没有用过，据说是个大杀器。<br/>
但是这里我选择了sublime。原谅我是一个可耻的外卖协会，sublime的界面让我在写代码的时候感觉非常舒服，而且支持语法高亮，有点儿简陋的语义提示，此外，在保存的时候会自动矫正错误格式。<br/>
sublime几乎可以算得上的免费。试用无时间限制，但是时不时会提示你购买，偶尔会觉得这一点儿非常烦，可以找下破解，kill掉这个。</p>

<p>闲话到此，这里提供下sublime的官方下载地址：<a href="http://www.sublimetext.com/2">戳我，我是地址君</a></p>

<ul>
<li>选择合适自己的版本，双击安装。</li>
<li><p>打开sublime，安装GoSubLime插件</p>

<blockquote>
<ul>
<li>按下<code>command＋shift＋p</code> [window用<code>ctrl＋shift＋p</code>]</li>
<li>输入<code>install</code>, 选择<code>install package</code>回车</li>
<li>在跳出的输入框中输入<code>GoSublime</code>, 选择<code>GoSublime</code>回车</li>
<li>输入<code>Go build</code>选中回车（这个属于可选）</li>
</ul>
</blockquote></li>
<li><p>下载GoCode，在iTerm中输入：</p></li>
</ul>

<pre><code class="language-bash">go get -u github.com/nsf/gocode
go install github.com/nsf/gocode
</code></pre>

<ul>
<li>修改sublime配置，选择菜单Preferences -&gt; Package Settings -&gt; Package Controll -&gt; Settings-User。打开文件，配置如下：</li>
</ul>

<pre><code class="language-json">{
    &quot;in_process_packages&quot;:
    [
    ],
    &quot;installed_packages&quot;:
    [
        &quot;Go Build&quot;,
        &quot;GoSublime&quot;,
        &quot;Package Control&quot;
    ]
}
</code></pre>

<p>重启之后，尝试编辑Go吧</p>

<p>⚠ 代码编写完成后，可以按command＋b呼出命令行</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC 环境]]></title>
    <link href="https://lorch.github.io/14767163933235.html"/>
    <updated>2016-10-17T22:59:53+08:00</updated>
    <id>https://lorch.github.io/14767163933235.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">修改mac终端的提示前缀</h2>

<pre><code class="language-shell">$ sudo scutil --set HostName [你想要的新hostname]
</code></pre>

<h2 id="toc_1">安装apt-get</h2>

<pre><code class="language-shell">$ curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1  
</code></pre>

<pre><code class="language-shell">$ sudo brew install wget
$ sudo brew install tomcat
$ sudo brew install unrar
    
</code></pre>

<h2 id="toc_2">安装cmake</h2>

<ul>
<li>在官网下载cmake.tar.gz并解压</li>
<li>进入解压的文件夹</li>
</ul>

<pre><code class="language-shell">$ tar xvf cmake-xxx.tar.gz
$ cd cmake-xxx
$ ./bootstrap
$ make
$ make all
</code></pre>

<h3 id="toc_3">安装maven</h3>

<ul>
<li>在官网下载maven-xxx.tar.gz并解压</li>
</ul>

<pre><code class="language-shell"># 若/usr/local/maven文件夹不存在，则新建一个
$ mv maven-xxx.tar.gz /usr/local/maven 
$ sudo vim /etc/bashrc

# 在bashrc文件尾部新增如下：
M3_HOME=/usr/local/maven
PATH=$M3_HOME/bin:$PATH
export M3_HOME PATH
#结束后保存

$ source bashrc

# 测试maven是否安装完毕
$ mvn -version

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式]]></title>
    <link href="https://lorch.github.io/14767161005061.html"/>
    <updated>2016-10-17T22:55:00+08:00</updated>
    <id>https://lorch.github.io/14767161005061.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">依赖倒置指导方针</h2>

<ul>
<li>变量不可以持有具体类的引用</li>
<li>不要让类派送自具体类</li>
<li>不要覆盖基类中已实现的方法</li>
</ul>

<h2 id="toc_1">设计原则</h2>

<ul>
<li>找出应用在可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起</li>
<li>针对接口编程，而不是针对实现编程</li>
<li>多用组合，少用继承</li>
<li>为了交互对象之间的松耦合设计而努力</li>
<li>类应该对扩展开放，对修改关闭</li>
<li>要依赖抽象，不要依赖具体</li>
<li>最少知识原则：只和你的密友谈话</li>
<li>好莱坞原则：别调用(打电话)我们，我们会调用(打电话给)你</li>
<li>单一责任：一个类应该只有一个引起变化的原因</li>
</ul>

<h2 id="toc_2">相关术语</h2>

<ul>
<li>内聚：用来度量一个类或模块紧密地达到单一目的或责任。当一个模块或者一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说他具有低内聚。</li>
</ul>

<h2 id="toc_3">模式定义</h2>

<h3 id="toc_4">策略模式</h3>

<blockquote>
<p>定义了算法簇，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
</blockquote>

<ul>
<li>良好的OO设计必须具备可用性，复用性，可维护三个特性</li>
</ul>

<h3 id="toc_5">观察者模式：</h3>

<blockquote>
<p>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新。</p>
</blockquote>

<ul>
<li>观察者模式定义了对象之间的一对多关系</li>
<li>主题（也就是可观察者）用一个共同的接口来更新观察者</li>
<li>观察者和可观察者之间用松耦合的方式结合，可观察者不知道观察者的细节，只知道可观察这实现了观察者的接口</li>
<li>使用此模式时，可从被观察者处push或者pull数据（然而，push的方式被认为更正确）</li>
<li>有多个观察者时，不可以依赖特点的通知次序</li>
</ul>

<h3 id="toc_6">装饰者模式：</h3>

<blockquote>
<p>动态地将责任附加到对象上，若扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
</blockquote>

<ul>
<li>继承属于拓展形式之一，但不见得是达到弹性设计的最佳方式</li>
<li>在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码</li>
<li>组合和委托可用于在运动时动态地加上新的行为</li>
<li>除了继承，装饰者模式也可以让我们扩展行为</li>
<li>装饰者模式意味着一群装饰者类，这些类用来包装具体组件</li>
<li>装饰者类反应出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）</li>
<li>装饰者可以在被装饰者的行为前面或后面加上自己的行为整个取代掉，而达到特定的目的</li>
<li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型</li>
<li>装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得复杂</li>
</ul>

<h3 id="toc_7">工厂方法模式：</h3>

<blockquote>
<p>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>
</blockquote>

<h3 id="toc_8">抽象工厂模式：</h3>

<blockquote>
<p>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
</blockquote>

<ul>
<li>所有的工厂都是用来封装对象的创建</li>
<li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦</li>
<li>工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象</li>
<li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中</li>
<li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li>
<li>工厂方法允许类将实例化延迟到子类进行</li>
<li>抽象工厂创建相关的 对象家族，而不需要依赖他们的具体类</li>
<li>依赖倒置原则，指导避免依赖具体类型，而要尽量依赖抽象</li>
<li>工厂是很有威力的技巧，帮助针对抽象编程，而不要针对具体类编程<br/></li>
</ul>

<h3 id="toc_9">单例模式：</h3>

<blockquote>
<p>确保一个类只有一个实例，并提供一个全局访问点。</p>
</blockquote>

<ul>
<li>单例模式确保程序中一个类最多只有一个实例</li>
<li>单例模式也提供访问这个实例的全局点</li>
<li>在JAVA中实现单例模式需要私有构造器、一个静态方法和一个静态变量</li>
<li>确定在性能和资源上的限制，然后小心地选择适当- 如果使用多个类加载器，可能导致单例失效而产生多个实例</li>
</ul>

<h3 id="toc_10">命令模式：</h3>

<blockquote>
<p>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
</blockquote>

<ul>
<li>命令模式将发出请求的对象和执行请求的对象解耦</li>
<li>在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接受者和一个或一组动作</li>
<li>调用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用</li>
<li>调用者可以接受命令当做参数，甚至在运行时动态地进行</li>
<li>命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态</li>
<li>宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销</li>
</ul>

<h3 id="toc_11">适配器模式</h3>

<pre><code>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
</code></pre>

<h3 id="toc_12">定义外观模式</h3>

<blockquote>
<p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
</blockquote>

<ul>
<li>当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器</li>
<li>当需要简化并同意一个很大的接口或者一群复杂的接口时，使用外观</li>
<li>适配器改变接口以符合客户的期望</li>
<li>外观将客户从一个复杂的子系统中解耦</li>
<li>实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小和复杂而定</li>
<li>实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行</li>
<li>适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多重继承</li>
<li>可以为子系统实现一个以上的外观</li>
<li>适配器将一个对象包装起来改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象“包装”起来以简化其接口</li>
</ul>

<h3 id="toc_13">模板方法模式</h3>

<blockquote>
<p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
</blockquote>

<ul>
<li>模板方法定义了算法的步骤，把这些步骤的实现延迟到子类</li>
<li>模板方法模式为我们提供了一种代码复用的重要技巧</li>
<li>模板方法的抽象类可以定义具体方法、抽象方法和钩子</li>
<li>抽象方法由子类实现</li>
<li>钩子是一种方法，它在抽象类中不做事，或者只做默认的事，子类可以选择要不要去覆盖它</li>
<li>为了防止子类改变模板方法中的算法，可以将模板方法申明为final</li>
<li>好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用底层模块</li>
<li>策略模式和模板模式都封装算法，一个用组合，一个用继承</li>
<li>工厂方法是模板方法的一个特殊版本</li>
</ul>

<h3 id="toc_14">迭代器模式</h3>

<blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>
</blockquote>

<ul>
<li>迭代器允许访问聚合的元素，而不需要暴露它的内部结构</li>
<li>迭代器将遍历聚合的工作封装进一个对象中</li>
<li>当使用迭代器的时候，我们依赖聚合提供遍历</li>
<li>迭代器提供了一个通用的接口，让我们遍历聚合的项，当我们编码使用聚合的项时，就可以使用多态机制</li>
</ul>

<h3 id="toc_15">组合模式</h3>

<blockquote>
<p>允许你将对象组合组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p>
</blockquote>

<ul>
<li>组合模式提供一个结构，可以同时包容个别对象以及组合对象</li>
<li>组合模式允许客户对个别对象以及组合对象一视同仁</li>
<li>组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点</li>
<li>在实现组合模式时，有许多设计上的折衷。要根据需要平衡透明性和安全性</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见编程概念]]></title>
    <link href="https://lorch.github.io/14767158161823.html"/>
    <updated>2016-10-17T22:50:16+08:00</updated>
    <id>https://lorch.github.io/14767158161823.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">FIFO[先入先出队列]</h2>

<p>First Input First Output的缩写，先入先出队列，这是一种传统的按序执行方法，先进入的指令先完成并引退，跟着才执行第二条指令。</p>

<h2 id="toc_1">RBAC</h2>

<p>基于角色的访问控制（Role-Based Access Control）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在RBAC中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。在一个组织中，角色是为了完成各种工作而创造，用户则依据它的责任和资格来被指派相应的角色，用户可以很容易地从一个角色被指派到另一个角色。角色可依新的需求和系统的合并而赋予新的权限，而权限也可根据需要而从某角色中回收。角色与角色的关系可以建立起来以囊括更广泛的客观情况。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异常处理中心]]></title>
    <link href="https://lorch.github.io/14767152130925.html"/>
    <updated>2016-10-17T22:40:13+08:00</updated>
    <id>https://lorch.github.io/14767152130925.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">在启动Android Studio时，弹出“Fetching Android SDK component information”。并且一直没有进入程序</h2>

<ul>
<li>打开Android Studio的安装目录下的bin目录</li>
<li>在bin目录下，找到idea.properties文件</li>
<li>打开idea.properties文件</li>
<li>在最后一行添加 <code>disable.android.first.run=true</code></li>
</ul>

<hr/>

<h2 id="toc_1">Unable to execute DX</h2>

<p>整个project包含好几个module，其中有一个jar包同时存在于两个module的libs下，在项目build的时候，两个相同的jar都被打包到dex文件中，编译器搞不定，就出了这么个错误了。解决的办法也比较简单：删除重复的jar，只保留一个！</p>

<hr/>

<h2 id="toc_2">No resource identifier found for attribute &#39;showAsAction&#39; in package &#39;android&#39;</h2>

<p>showAsAction was added in API level 11要将API提升到11，添加 &quot;android-support-v7-appcompat.jar&quot; 到Android库（ Private Libraries）<br/>
android:showAsAction = &quot;never&quot;<br/>
当你的应用程序目标设为蜂巢平台时，你可以利用Action Bar部件提供的全部功能，将你的选项菜单项放在Action Bar的右上角，对用户来说使用更方便，控制该行为的主菜单项属性是android:showAsAction。<br/>
　　这个属性可接受的值有：<br/>
　　1、always：这个值会使菜单项一直显示在Action Bar上。<br/>
　　2、ifRoom：如果有足够的空间，这个值会使菜单项显示在Action Bar上。<br/>
　　3、never：这个值使菜单项永远都不出现在Action Bar上。<br/>
　　4、withText：这个值使菜单项和它的图标，菜单文本一起显示。<br/>
不过这里没有用到这高版本，此处删除这个属性就OK了。</p>

<hr/>

<h2 id="toc_3">找不到 android.support.v4.app.TaskStackBuilder$SupportParentable 的类文件</h2>

<p>把 <code>android-support-v4.jar</code> 替换成<code>..\sdk\extras\android\support\v7\appcompat\libs下的android-support-v4.jar</code>。</p>

<hr/>

<h2 id="toc_4">Failure [INSTALL_FAILED_OLDER_SDK]</h2>

<p><code>build.grade</code> 下的 <code>minSdkVersion</code> 、<code>targetSdkVersion</code> 需要与虚拟设备保持一致。</p>

<hr/>

<h2 id="toc_5">intellij中出现19不支持错误</h2>

<p>部分png文件在编译gradle时，会出现该错误。将文件改成jpg格式即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android的Aidl深入理解]]></title>
    <link href="https://lorch.github.io/14767153911909.html"/>
    <updated>2016-10-17T22:43:11+08:00</updated>
    <id>https://lorch.github.io/14767153911909.html</id>
    <content type="html"><![CDATA[
<p><strong>引用自：</strong><br/>
<a href="http://blog.csdn.net/singwhatiwanna/article/details/17041691">http://blog.csdn.net/singwhatiwanna/article/details/17041691</a></p>

<h2 id="toc_0">AIDL的作用</h2>

<p>AIDL(Android Interface Definition Language) 是一种IDL语言，用于生成可以在Android两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中(例如Activity)要调用另一个进程中(例如Service)对象的操作，就可以使用AIDL生成可序列化的参数。</p>

<hr/>

<h2 id="toc_1">AIDL的使用场合</h2>

<p>只有当允许客户端从不同的应用程序为了进程间通信而去访问你的service，以及想在你的service处理多线程。无论如何，在使用AIDL之前，必须理解如何绑定service——bindService。</p>

<hr/>

<h2 id="toc_2">如何使用AIDL</h2>

<p><strong>To be continus...</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android系列之SlidingMenu]]></title>
    <link href="https://lorch.github.io/14767156965797.html"/>
    <updated>2016-10-17T22:48:16+08:00</updated>
    <id>https://lorch.github.io/14767156965797.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">添加SlidingMenu到自己的项目上：</h2>

<pre><code>由于这是一个开源的项目，没有jar包，所以在这里给出添加方法［在android studio上］
</code></pre>

<ol>
<li>下载slidingMenu源代码， <a href="https://github.com/jfeinstein10/SlidingMenu">戳我，我是地址君</a></li>
<li>新建一个Android项目</li>
<li>单击Project structure --&gt; 单击“＋” --&gt; 选择Phone and Table Application 并在下面的more modules里选择 Import exist project</li>
<li><p>单击next，并选择slidingMenu的下载路径［只需要library部分］，单击finish</p>

<p>到此， 准备工作完成。<br/>
⚠ 导入之后出现不能识别的问题，注意项目中的gradle，看看依赖关系中是否有slidingMenu项目。例如：</p></li>
</ol>

<pre><code class="language-gradle">    dependencies{
        compile fileTree(dir: &#39;lib&#39;, include: [&#39;*.jar&#39;])
        compile (project (&quot;:slidingMenu&quot;))
        complie &#39;com.android.support:appcompat-v7:21.0.2&#39;
    }
</code></pre>

<h2 id="toc_1">SlidingMenu 的常用属性：</h2>

<pre><code class="language-java">menu.setMode(SlidingMenu.LEFT);
//设置左滑菜单

menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
//设置滑动的屏幕范围，该设置为全屏区域都可以滑动

menu.setShadowDrawable(R.drawable.shadow);
//设置阴影图片

menu.setShadowWidthRes(R.dimen.shadow_width);
//设置阴影图片的宽度

menu.setBehindOffsetRes(R.dimen.slidingmenu_offset);
//SlidingMenu划出时主页面显示的剩余宽度

menu.setBehindWidth(400);
//设置SlidingMenu菜单的宽度

menu.setFadeDegree(0.35f);
//SlidingMenu滑动时的渐变程度

menu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT);
//使SlidingMenu附加在Activity上

menu.setMenu(R.layout.menu_layout);
//设置menu的布局文件

menu.toggle();
//动态判断自动关闭或开启SlidingMenu

menu.showMenu();
//显示SlidingMenu

menu.showContent();
//显示内容

menu.setOnOpenListener(onOpenListener);
//监听slidingmenu打开,关于关闭menu有两个监听，简单的来说，对于menu close事件，一个是when,一个是after 

menu.OnClosedListener(OnClosedListener);
//监听slidingmenu关闭时事件

menu.OnClosedListener(OnClosedListener);
//监听slidingmenu关闭后事件
</code></pre>

<pre><code>⚠ 左右都可以划出SlidingMenu菜单只需要设置下面的属性，然后设置右侧菜单的布局文件
    menu.setMode(SlidingMenu.LEFT_RIGHT);
    menu.setSecondaryShadowDrawable(R.drawable.shadowright);
    //右侧菜单的阴影图片
</code></pre>

<h2 id="toc_2">DEMO</h2>

<p>布局： 这里我偷个懒， 三个界面使用同一个layout［activity_test.xml］</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;
    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:text=&quot;Hello, World&quot;
        android:gravity=&quot;center&quot;
        android:textSize=&quot;40sp&quot;/&gt;
 
&lt;/LinearLayout&gt;
</code></pre>

<p>阴影：这里我做了左右侧滑，所以需要两个shadow文件［shadow.xml, shadow_2.xml］</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
    &lt;gradient
        android:endColor=&quot;#33000000&quot;
        android:centerColor=&quot;#11000000&quot;
        android:startColor=&quot;#00000000&quot; /&gt;
&lt;/shape&gt;
</code></pre>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
 &lt;gradient
     android:endColor=&quot;#00508074&quot;
     android:centerColor=&quot;#113583ff&quot;
     android:startColor=&quot;#333583ff&quot; /&gt;
&lt;/shape&gt;
</code></pre>

<pre><code>⚠ 在values/dimens.xml中写一下需要用到的属性
</code></pre>

<pre><code class="language-xml">&lt;resources&gt;
 &lt;!-- Default screen margins, per the Android Design guidelines. --&gt;
 &lt;dimen name=&quot;activity_horizontal_margin&quot;&gt;16dp&lt;/dimen&gt;
 &lt;dimen name=&quot;activity_vertical_margin&quot;&gt;16dp&lt;/dimen&gt;
 &lt;dimen name=&quot;shadow_width&quot;&gt; 15dp&lt;/dimen &gt;
 &lt;dimen name=&quot;slidingmenu_offset&quot;&gt;60dp&lt;/dimen&gt;
&lt;/resources&gt;
</code></pre>

<p>Activity的实现</p>

<pre><code class="language-java">import android.app.Activity;
import android.os.Bundle;
import android.view.Menu;
 
import com.slidingmenu.lib.SlidingMenu;
import com.violorch.menudemo.R;
 
/**
 * Created by violorch on 14-11-27.
 */
public class TestActivity extends Activity {
 
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_test);
 
        /*** 初始化侧滑菜单 Begin ***/
        SlidingMenu menu = new SlidingMenu( this);
        //这里模式设置为左右都有菜单，RIGHT显示右菜单，LEFT显示左菜单，LEFT_RIGH显示左右菜单
        menu.setMode(SlidingMenu.LEFT_RIGHT);
        menu.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN );
 
        //设置阴影
        menu.setShadowWidthRes(R.dimen.shadow_width);
        menu.setBehindOffsetRes(R.dimen.slidingmenu_offset );
        menu.setFadeDegree(0.35f);
        menu.attachToActivity( this, SlidingMenu.SLIDING_CONTENT );
        // left
        menu.setMenu(R.layout.activity_ceshi);
        menu.setShadowDrawable(R.drawable.shadow);
        // right
        menu.setSecondaryMenu(R.layout.activity_test);
        menu.setSecondaryShadowDrawable(R.drawable.shadow_2);
        /*** 初始化侧滑菜单 End ***/
    }
 
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu);
        return true;
    }
 
}
</code></pre>

<p>⚠ 到此， slidingMenu的初步实现已经完成。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异常处理中心]]></title>
    <link href="https://lorch.github.io/14767150467979.html"/>
    <updated>2016-10-17T22:37:26+08:00</updated>
    <id>https://lorch.github.io/14767150467979.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">org.hibernate.HibernateException: Could not obtain transaction-synchronized Session for current thread</h2>

<p>在配置spring mvc时，如果报上面的错，那么在web.xml文件中加上下面的配置</p>

<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;SpringOpenSessionInViewFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.orm.hibernate4.support.OpenSessionInViewFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;SpringOpenSessionInViewFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>

<hr/>

<h2 id="toc_1">javax.servlet.ServletException: Could not resolve view with name</h2>

<p>拦截了一个不能转换为servlet的文件。</p>

<hr/>

<h2 id="toc_2">spring 4.0.2 换成 spring 4.1.6， @ResponseBody时，出现如下错误</h2>

<pre><code>java.lang.IllegalStateException: getOutputStream() has already been called for this response
</code></pre>

<p>解决方法：</p>

<pre><code class="language-xml">        &lt;!-- jackson --&gt;
        &lt;!--&lt;dependency&gt;--&gt;
            &lt;!--&lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;--&gt;
            &lt;!--&lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;--&gt;
        &lt;!--&lt;/dependency&gt;--&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;2.5.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>

<p>将上面的jar换成下面的</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[向上转型和向下转型]]></title>
    <link href="https://lorch.github.io/14767146711676.html"/>
    <updated>2016-10-17T22:31:11+08:00</updated>
    <id>https://lorch.github.io/14767146711676.html</id>
    <content type="html"><![CDATA[
<p>转自 <a href="http://www.cnblogs.com/fickleness/archive/2013/06/21/3149011.html">Java向上转型和向下转型</a></p>

<p>转型是在继承的基础上而言的，继承是面向对象语言中，代码复用的一种机制。通过继承，子类可以复用父类的功能。如果父类不恩能够满足当前子类的需求，则子类可以重写弗雷中的方法来加以扩展。</p>

<p><strong>向下转型：</strong>子类引用的对象转换为父类类型。通俗地说就是将子类对象转为父类对象。此处父类对象可以是借口</p>

<p><strong>向下转型：</strong>父类引用的对象转换为子类类型。</p>

<p>前者是一个向上转型。Animal dog引指向new Dog(); 子类对象当成父类对象，只能调用父类的成员，如果子类重写了父类的方法，就根据这个引用指向调用子类重写的这个方法（这个方法就是覆盖Override）。这个调用过程就称为“动态绑定”。</p>

<p><strong>转型需要注意的问题：</strong>：<br/>
向上转型时，父类指向子类引用对象会遗失父类对象没有的其他方法，在编译时，系统会提示找不到方法的错误。</p>

<p><strong>在向下转型过程中，分为两种情况</strong>：</p>

<ul>
<li>情况一：如果父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的。</li>
<li>情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。</li>
</ul>

<p><em>实例如下：</em></p>

<pre><code class="language-java">public class Father {
    public void smile(){
        System.out.println(&quot;Father smile()...&quot;);
    }
}

class Child extends Father{
    @Override
    public void smile() {
        System.out.println(&quot;Child smile sounds sweet...&quot;);
    }
    public void c(){
        System.out.println(&quot;Child c()...&quot;);
    }
}

class main{
    public static void main(String[] args) {
        Father g1 = new Child(); //向上转型
        g1.smile(); //Child smile sounds sweet...
        Child mmg = (Child)g1; //向下转型,编译和运行皆不会出错
        mmg.smile(); //Child smile sounds sweet...
        mmg.c(); //Child c()...
        Father g2 = new Father();
        //Child mmg1 = (Child)g2; //不安全的向下转型,编译无错但会运行会出错
        //mmg1.smile();
        //mmg1.c();
        if(g2 instanceof Child){
            Child mmg1 = (Child)g2;
            mmg1.smile();
            mmg1.c();
        }
    }
}
</code></pre>

<p><strong>总结：</strong></p>

<ul>
<li>父类引用可以指向子类对象，子类引用不能指向父类对象。</li>
<li>把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转型。
如Father father = new Child();</li>
<li>把指向子类对象的父类引用赋给子类引用叫向下转型（downcasting），要强制转型。如father就是一个指向子类对象的父类引用，把father赋给子类引用son 即Child child =（Child）father；其中father前面的（Son）必须添加，进行强制转换。</li>
<li>upcasting 会丢失子类特有的方法,但是子类overriding 父类的方法，子类方法有效</li>
<li>向上转型的作用，减少重复代码，父类为参数，调有时用子类作为参数，就是利用了向上转型。这样使代码变得简洁。体现了JAVA的抽象编程思想。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 之 并发基础]]></title>
    <link href="https://lorch.github.io/14767146501769.html"/>
    <updated>2016-10-17T22:30:50+08:00</updated>
    <id>https://lorch.github.io/14767146501769.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">关键字</h2>

<h3 id="toc_1">transient：</h3>

<ul>
<li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li>
<li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</li>
<li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</li>
</ul>

<h3 id="toc_2">volatile：</h3>

<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>

<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>

<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ul>

<hr/>

<h2 id="toc_3">happens-before原则：</h2>

<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>

<hr/>

<h2 id="toc_4">概念术语</h2>

<ul>
<li><p>竞态条件：<br/>
由于不恰当的执行时序而出现不正确的结果。</p></li>
<li><p>数据竞争：<br/>
如果在访问共享的非final类型的域时，没有采用同步来进行协同，那么就会出现数据竞争。当一个线程写入一个变量而另一个线程接下来读取这个变量，或者读取一个之前由另一个线程写入的变量时，并且在这两个线程之间没有使用同步，那么久可能出现数据竞争。</p></li>
</ul>

<hr/>

<h2 id="toc_5">注意点</h2>

<ul>
<li>无状态对象一定是线程安全的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven系列--pom.xml 配置详解]]></title>
    <link href="https://lorch.github.io/14767146103825.html"/>
    <updated>2016-10-17T22:30:10+08:00</updated>
    <id>https://lorch.github.io/14767146103825.html</id>
    <content type="html"><![CDATA[
<pre><code class="language-xml">
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;  

    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  

    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;  



    &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。--&gt;

    &lt;parent&gt;

     &lt;!--被继承的父项目的构件标识符--&gt;

     &lt;artifactId/&gt;

     &lt;!--被继承的父项目的全球唯一标识符--&gt;

     &lt;groupId/&gt;

     &lt;!--被继承的父项目的版本--&gt;

     &lt;version/&gt;

     &lt;!--父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。--&gt;

     &lt;relativePath/&gt;

 &lt;/parent&gt;



 &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。--&gt;    

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  

    &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app--&gt;  

    &lt;groupId&gt;asia.banseon&lt;/groupId&gt;  

    &lt;!--构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。--&gt;  

    &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;  

    &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt;  

    &lt;packaging&gt;jar&lt;/packaging&gt;  

    &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号--&gt;  

    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  

    &lt;!--项目的名称, Maven产生的文档用--&gt;  

    &lt;name&gt;banseon-maven&lt;/name&gt;  

    &lt;!--项目主页的URL, Maven产生的文档用--&gt;  

    &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;  

    &lt;!--项目的详细描述, Maven 产生的文档用。  当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。--&gt;  

    &lt;description&gt;A maven project to study maven.&lt;/description&gt;  

    &lt;!--描述了这个项目构建环境中的前提条件。--&gt;

 &lt;prerequisites&gt;

  &lt;!--构建该项目或使用该插件所需要的Maven的最低版本--&gt;

    &lt;maven/&gt;

 &lt;/prerequisites&gt;

 &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira--&gt;  

    &lt;issueManagement&gt;

     &lt;!--问题管理系统（例如jira）的名字，--&gt;  

        &lt;system&gt;jira&lt;/system&gt;  

        &lt;!--该项目使用的问题管理系统的URL--&gt;

        &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;  

    &lt;/issueManagement&gt;  

    &lt;!--项目持续集成信息--&gt;

 &lt;ciManagement&gt;

  &lt;!--持续集成系统的名字，例如continuum--&gt;

  &lt;system/&gt;

  &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。--&gt;

  &lt;url/&gt;

  &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告）--&gt;

  &lt;notifiers&gt;

   &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者--&gt;

   &lt;notifier&gt;

    &lt;!--传送通知的途径--&gt;

    &lt;type/&gt;

    &lt;!--发生错误时是否通知--&gt;

    &lt;sendOnError/&gt;

    &lt;!--构建失败时是否通知--&gt;

    &lt;sendOnFailure/&gt;

    &lt;!--构建成功时是否通知--&gt;

    &lt;sendOnSuccess/&gt;

    &lt;!--发生警告时是否通知--&gt;

    &lt;sendOnWarning/&gt;

    &lt;!--不赞成使用。通知发送到哪里--&gt;

    &lt;address/&gt;

    &lt;!--扩展配置项--&gt;

    &lt;configuration/&gt;

   &lt;/notifier&gt;

  &lt;/notifiers&gt;

 &lt;/ciManagement&gt;

 &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。--&gt;

    &lt;inceptionYear/&gt;

    &lt;!--项目相关邮件列表信息--&gt;  

    &lt;mailingLists&gt;

     &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。--&gt;  

        &lt;mailingList&gt;  

         &lt;!--邮件的名称--&gt;

            &lt;name&gt;Demo&lt;/name&gt;  

            &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;  

            &lt;post&gt;banseon@126.com&lt;/post&gt;  

            &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;  

            &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt;  

            &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建--&gt;  

            &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt;  

            &lt;!--你可以浏览邮件信息的URL--&gt;

            &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt;  

        &lt;/mailingList&gt;  

    &lt;/mailingLists&gt;  

    &lt;!--项目开发者列表--&gt;  

    &lt;developers&gt;  

     &lt;!--某个项目开发者的信息--&gt;

        &lt;developer&gt;  

         &lt;!--SCM里项目开发者的唯一标识符--&gt;

            &lt;id&gt;HELLO WORLD&lt;/id&gt;  

            &lt;!--项目开发者的全名--&gt;

            &lt;name&gt;banseon&lt;/name&gt;  

            &lt;!--项目开发者的email--&gt;

            &lt;email&gt;banseon@126.com&lt;/email&gt;  

            &lt;!--项目开发者的主页的URL--&gt;

            &lt;url/&gt;

            &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色--&gt;

            &lt;roles&gt;  

                &lt;role&gt;Project Manager&lt;/role&gt;  

                &lt;role&gt;Architect&lt;/role&gt;  

            &lt;/roles&gt; 

            &lt;!--项目开发者所属组织--&gt; 

            &lt;organization&gt;demo&lt;/organization&gt;  

            &lt;!--项目开发者所属组织的URL--&gt;

            &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;  

            &lt;!--项目开发者属性，如即时消息如何处理等--&gt;

            &lt;properties&gt;  

                &lt;dept&gt;No&lt;/dept&gt;  

            &lt;/properties&gt; 

            &lt;!--项目开发者所在时区， -11到12范围内的整数。--&gt; 

            &lt;timezone&gt;-5&lt;/timezone&gt;  

        &lt;/developer&gt;  

    &lt;/developers&gt;  

    &lt;!--项目的其他贡献者列表--&gt;  

    &lt;contributors&gt;

     &lt;!--项目的其他贡献者。参见developers/developer元素--&gt;

     &lt;contributor&gt;

   &lt;name/&gt;&lt;email/&gt;&lt;url/&gt;&lt;organization/&gt;&lt;organizationUrl/&gt;&lt;roles/&gt;&lt;timezone/&gt;&lt;properties/&gt;

     &lt;/contributor&gt;     

    &lt;/contributors&gt;    

    &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。--&gt;  

    &lt;licenses&gt;

     &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。--&gt;  

        &lt;license&gt; 

         &lt;!--license用于法律上的名称--&gt; 

            &lt;name&gt;Apache 2&lt;/name&gt;  

            &lt;!--官方的license正文页面的URL--&gt;

            &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;  

            &lt;!--项目分发的主要方式：

              repo，可以从Maven库下载

              manual， 用户必须手动下载和安装依赖--&gt;

            &lt;distribution&gt;repo&lt;/distribution&gt;  

            &lt;!--关于license的补充信息--&gt;

            &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;  

        &lt;/license&gt;  

    &lt;/licenses&gt;  

    &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。--&gt;  

    &lt;scm&gt;  

        &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。--&gt;  

        &lt;connection&gt;  

            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)   

        &lt;/connection&gt;  

        &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读--&gt;

        &lt;developerConnection&gt;  

            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk   

        &lt;/developerConnection&gt;

        &lt;!--当前代码的标签，在开发阶段默认为HEAD--&gt;

        &lt;tag/&gt;        

        &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。--&gt;  

        &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;  

    &lt;/scm&gt;  

    &lt;!--描述项目所属组织的各种属性。Maven产生的文档用--&gt;  

    &lt;organization&gt;  

     &lt;!--组织的全名--&gt;

        &lt;name&gt;demo&lt;/name&gt;  

        &lt;!--组织主页的URL--&gt;

        &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;  

    &lt;/organization&gt;

    &lt;!--构建项目需要的信息--&gt;

    &lt;build&gt;

     &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;

  &lt;sourceDirectory/&gt;

  &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。--&gt;

  &lt;scriptSourceDirectory/&gt;

  &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。--&gt;

  &lt;testSourceDirectory/&gt;

  &lt;!--被编译过的应用程序class文件存放的目录。--&gt;

  &lt;outputDirectory/&gt;

  &lt;!--被编译过的测试class文件存放的目录。--&gt;

  &lt;testOutputDirectory/&gt;

  &lt;!--使用来自该项目的一系列构建扩展--&gt;

  &lt;extensions&gt;

   &lt;!--描述使用到的构建扩展。--&gt;

   &lt;extension&gt;

    &lt;!--构建扩展的groupId--&gt;

    &lt;groupId/&gt;

    &lt;!--构建扩展的artifactId--&gt;

    &lt;artifactId/&gt;

    &lt;!--构建扩展的版本--&gt;

    &lt;version/&gt;

   &lt;/extension&gt;

  &lt;/extensions&gt;

  &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值--&gt;

  &lt;defaultGoal/&gt;

  &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;

  &lt;resources&gt;

   &lt;!--这个元素描述了项目相关或测试相关的所有资源路径--&gt;

   &lt;resource&gt;

    &lt;!--描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。--&gt;

    &lt;targetPath/&gt;

    &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。--&gt;

    &lt;filtering/&gt;

    &lt;!--描述存放资源的目录，该路径相对POM路径--&gt;

    &lt;directory/&gt;

    &lt;!--包含的模式列表，例如**/*.xml.--&gt;

    &lt;includes/&gt;

    &lt;!--排除的模式列表，例如**/*.xml--&gt;

    &lt;excludes/&gt;

   &lt;/resource&gt;

  &lt;/resources&gt;

  &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。--&gt;

  &lt;testResources&gt;

   &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明--&gt;

   &lt;testResource&gt;

    &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;

   &lt;/testResource&gt;

  &lt;/testResources&gt;

  &lt;!--构建产生的所有文件存放的目录--&gt;

  &lt;directory/&gt;

  &lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。--&gt;

  &lt;finalName/&gt;

  &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表--&gt;

  &lt;filters/&gt;

  &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置--&gt;

  &lt;pluginManagement&gt;

   &lt;!--使用的插件列表 。--&gt;

   &lt;plugins&gt;

    &lt;!--plugin元素包含描述插件所需要的信息。--&gt;

    &lt;plugin&gt;

     &lt;!--插件在仓库里的group ID--&gt;

     &lt;groupId/&gt;

     &lt;!--插件在仓库里的artifact ID--&gt;

     &lt;artifactId/&gt;

     &lt;!--被使用的插件的版本（或版本范围）--&gt;

     &lt;version/&gt;

     &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。--&gt;

     &lt;extensions/&gt;

     &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。--&gt;

     &lt;executions&gt;

      &lt;!--execution元素包含了插件执行需要的信息--&gt;

      &lt;execution&gt;

       &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标--&gt;

       &lt;id/&gt;

       &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段--&gt;

       &lt;phase/&gt;

       &lt;!--配置的执行目标--&gt;

       &lt;goals/&gt;

       &lt;!--配置是否被传播到子POM--&gt;

       &lt;inherited/&gt;

       &lt;!--作为DOM对象的配置--&gt;

       &lt;configuration/&gt;

      &lt;/execution&gt;

     &lt;/executions&gt;

     &lt;!--项目引入插件所需要的额外依赖--&gt;

     &lt;dependencies&gt;

      &lt;!--参见dependencies/dependency元素--&gt;

      &lt;dependency&gt;

       ......

      &lt;/dependency&gt;

     &lt;/dependencies&gt;     

     &lt;!--任何配置是否被传播到子项目--&gt;

     &lt;inherited/&gt;

     &lt;!--作为DOM对象的配置--&gt;

     &lt;configuration/&gt;

    &lt;/plugin&gt;

   &lt;/plugins&gt;

  &lt;/pluginManagement&gt;

  &lt;!--使用的插件列表--&gt;

  &lt;plugins&gt;

   &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;

   &lt;plugin&gt;

    &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;

    &lt;executions&gt;

     &lt;execution&gt;

      &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;

     &lt;/execution&gt;

    &lt;/executions&gt;

    &lt;dependencies&gt;

     &lt;!--参见dependencies/dependency元素--&gt;

     &lt;dependency&gt;

      ......

     &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;

   &lt;/plugin&gt;

  &lt;/plugins&gt;

 &lt;/build&gt;

 &lt;!--在列的项目构建profile，如果被激活，会修改构建处理--&gt;

 &lt;profiles&gt;

  &lt;!--根据环境参数或命令行参数激活某个构建处理--&gt;

  &lt;profile&gt;

   &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。--&gt;

   &lt;id/&gt;

   &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它

   能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。--&gt;

   &lt;activation&gt;

    &lt;!--profile默认是否激活的标志--&gt;

    &lt;activeByDefault/&gt;

    &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。--&gt;

    &lt;jdk/&gt;

    &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。--&gt;

    &lt;os&gt;

     &lt;!--激活profile的操作系统的名字--&gt;

     &lt;name&gt;Windows XP&lt;/name&gt;

     &lt;!--激活profile的操作系统所属家族(如 &#39;windows&#39;)--&gt;

     &lt;family&gt;Windows&lt;/family&gt;

     &lt;!--激活profile的操作系统体系结构 --&gt;

     &lt;arch&gt;x86&lt;/arch&gt;

     &lt;!--激活profile的操作系统版本--&gt;

     &lt;version&gt;5.1.2600&lt;/version&gt;

    &lt;/os&gt;

    &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值

    字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段--&gt;

    &lt;property&gt;

     &lt;!--激活profile的属性的名称--&gt;

     &lt;name&gt;mavenVersion&lt;/name&gt;

     &lt;!--激活profile的属性的值--&gt;

     &lt;value&gt;2.0.3&lt;/value&gt;

    &lt;/property&gt;

    &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活

    profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。--&gt;

    &lt;file&gt;

     &lt;!--如果指定的文件存在，则激活profile。--&gt;

     &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt;

     &lt;!--如果指定的文件不存在，则激活profile。--&gt;

     &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt;

    &lt;/file&gt;

   &lt;/activation&gt;

   &lt;!--构建项目所需要的信息。参见build元素--&gt;

   &lt;build&gt;

    &lt;defaultGoal/&gt;

    &lt;resources&gt;

     &lt;resource&gt;

      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;

     &lt;/resource&gt;

    &lt;/resources&gt;

    &lt;testResources&gt;

     &lt;testResource&gt;

      &lt;targetPath/&gt;&lt;filtering/&gt;&lt;directory/&gt;&lt;includes/&gt;&lt;excludes/&gt;

     &lt;/testResource&gt;

    &lt;/testResources&gt;

    &lt;directory/&gt;&lt;finalName/&gt;&lt;filters/&gt;

    &lt;pluginManagement&gt;

     &lt;plugins&gt;

      &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;

      &lt;plugin&gt;

       &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;

       &lt;executions&gt;

        &lt;execution&gt;

         &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;

        &lt;/execution&gt;

       &lt;/executions&gt;

       &lt;dependencies&gt;

        &lt;!--参见dependencies/dependency元素--&gt;

        &lt;dependency&gt;

         ......

        &lt;/dependency&gt;

       &lt;/dependencies&gt;

       &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;

      &lt;/plugin&gt;

     &lt;/plugins&gt;

    &lt;/pluginManagement&gt;

    &lt;plugins&gt;

     &lt;!--参见build/pluginManagement/plugins/plugin元素--&gt;

     &lt;plugin&gt;

      &lt;groupId/&gt;&lt;artifactId/&gt;&lt;version/&gt;&lt;extensions/&gt;

      &lt;executions&gt;

       &lt;execution&gt;

        &lt;id/&gt;&lt;phase/&gt;&lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;

       &lt;/execution&gt;

      &lt;/executions&gt;

      &lt;dependencies&gt;

       &lt;!--参见dependencies/dependency元素--&gt;

       &lt;dependency&gt;

        ......

       &lt;/dependency&gt;

      &lt;/dependencies&gt;

      &lt;goals/&gt;&lt;inherited/&gt;&lt;configuration/&gt;

     &lt;/plugin&gt;

    &lt;/plugins&gt;

   &lt;/build&gt;

   &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;

   &lt;modules/&gt;

   &lt;!--发现依赖和扩展的远程仓库列表。--&gt;

   &lt;repositories&gt;

    &lt;!--参见repositories/repository元素--&gt;

    &lt;repository&gt;

     &lt;releases&gt;

      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;

     &lt;/releases&gt;

     &lt;snapshots&gt;

      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;

     &lt;/snapshots&gt;

     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;

    &lt;/repository&gt;

   &lt;/repositories&gt;

   &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;

   &lt;pluginRepositories&gt;

    &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;    

    &lt;pluginRepository&gt;

     &lt;releases&gt;

      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;

     &lt;/releases&gt;

     &lt;snapshots&gt;

      &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;

     &lt;/snapshots&gt;

     &lt;id/&gt;&lt;name/&gt;&lt;url/&gt;&lt;layout/&gt;

    &lt;/pluginRepository&gt;

   &lt;/pluginRepositories&gt;

   &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;

   &lt;dependencies&gt;

    &lt;!--参见dependencies/dependency元素--&gt;

    &lt;dependency&gt;

     ......

    &lt;/dependency&gt;

   &lt;/dependencies&gt;

   &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;

   &lt;reports/&gt;   

   &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素--&gt;

   &lt;reporting&gt;

    ......

   &lt;/reporting&gt;

   &lt;!--参见dependencyManagement元素--&gt;

   &lt;dependencyManagement&gt;

    &lt;dependencies&gt;

     &lt;!--参见dependencies/dependency元素--&gt;

     &lt;dependency&gt;

      ......

     &lt;/dependency&gt;

    &lt;/dependencies&gt;

   &lt;/dependencyManagement&gt;

   &lt;!--参见distributionManagement元素--&gt;

   &lt;distributionManagement&gt;

    ......

   &lt;/distributionManagement&gt;

   &lt;!--参见properties元素--&gt;

   &lt;properties/&gt;

  &lt;/profile&gt;

 &lt;/profiles&gt;

 &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径--&gt;

 &lt;modules/&gt;

    &lt;!--发现依赖和扩展的远程仓库列表。--&gt;  

    &lt;repositories&gt;  

     &lt;!--包含需要连接到远程仓库的信息--&gt;

        &lt;repository&gt; 

         &lt;!--如何处理远程仓库里发布版本的下载--&gt;

         &lt;releases&gt;

          &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;

    &lt;enabled/&gt;

    &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。--&gt;

    &lt;updatePolicy/&gt;

    &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。--&gt;

    &lt;checksumPolicy/&gt;

   &lt;/releases&gt;

   &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素--&gt;

   &lt;snapshots&gt;

    &lt;enabled/&gt;&lt;updatePolicy/&gt;&lt;checksumPolicy/&gt;

   &lt;/snapshots&gt;

   &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库--&gt;

   &lt;id&gt;banseon-repository-proxy&lt;/id&gt;  

   &lt;!--远程仓库名称--&gt;

            &lt;name&gt;banseon-repository-proxy&lt;/name&gt;  

            &lt;!--远程仓库URL，按protocol://hostname/path形式--&gt;

            &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;  

            &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。--&gt;

            &lt;layout&gt;default&lt;/layout&gt;            

        &lt;/repository&gt;  

    &lt;/repositories&gt;

    &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表--&gt;

    &lt;pluginRepositories&gt;

     &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素--&gt;

  &lt;pluginRepository&gt;

   ......

  &lt;/pluginRepository&gt;

 &lt;/pluginRepositories&gt;

    

    &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。--&gt;  

    &lt;dependencies&gt;  

        &lt;dependency&gt;

   &lt;!--依赖的group ID--&gt;

            &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;  

            &lt;!--依赖的artifact ID--&gt;

            &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;  

            &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。--&gt;

            &lt;version&gt;3.8.1&lt;/version&gt;  

            &lt;!--依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在plugin里定义新的类型。所以前面的类型的例子不完整。--&gt;

            &lt;type&gt;jar&lt;/type&gt;

            &lt;!--依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。--&gt;

            &lt;classifier&gt;&lt;/classifier&gt;

            &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 

                - compile ：默认范围，用于编译   

                - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath   

                - runtime: 在执行时需要使用   

                - test:    用于test任务时使用   

                - system: 需要外在提供相应的元素。通过systemPath来取得   

                - systemPath: 仅用于范围为system。提供相应的路径   

                - optional:   当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用--&gt;  

            &lt;scope&gt;test&lt;/scope&gt;    

            &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。--&gt; 

            &lt;systemPath&gt;&lt;/systemPath&gt;  

            &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题--&gt; 

            &lt;exclusions&gt;

             &lt;exclusion&gt;  

                    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  

                    &lt;groupId&gt;org.springframework&lt;/groupId&gt;  

                &lt;/exclusion&gt;  

            &lt;/exclusions&gt;    

            &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。--&gt;  

            &lt;optional&gt;true&lt;/optional&gt;

        &lt;/dependency&gt;

    &lt;/dependencies&gt; 

    &lt;!--不赞成使用. 现在Maven忽略该元素.--&gt;

    &lt;reports&gt;&lt;/reports&gt;

    &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。--&gt; 

 &lt;reporting&gt;

  &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。--&gt;

  &lt;excludeDefaults/&gt;

  &lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。--&gt;

  &lt;outputDirectory/&gt;

  &lt;!--使用的报表插件和他们的配置。--&gt;

  &lt;plugins&gt;

   &lt;!--plugin元素包含描述报表插件需要的信息--&gt;

   &lt;plugin&gt;

    &lt;!--报表插件在仓库里的group ID--&gt;

    &lt;groupId/&gt;

    &lt;!--报表插件在仓库里的artifact ID--&gt;

    &lt;artifactId/&gt;

    &lt;!--被使用的报表插件的版本（或版本范围）--&gt;

    &lt;version/&gt;

    &lt;!--任何配置是否被传播到子项目--&gt;

    &lt;inherited/&gt;

    &lt;!--报表插件的配置--&gt;

    &lt;configuration/&gt;

    &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标--&gt;

    &lt;reportSets&gt;

     &lt;!--表示报表的一个集合，以及产生该集合的配置--&gt;

     &lt;reportSet&gt;

      &lt;!--报表集合的唯一标识符，POM继承时用到--&gt;

      &lt;id/&gt;

      &lt;!--产生报表集合时，被使用的报表的配置--&gt;

      &lt;configuration/&gt;

      &lt;!--配置是否被继承到子POMs--&gt;

      &lt;inherited/&gt;

      &lt;!--这个集合里使用到哪些报表--&gt;

      &lt;reports/&gt;

     &lt;/reportSet&gt;

    &lt;/reportSets&gt;

   &lt;/plugin&gt;

  &lt;/plugins&gt;

 &lt;/reporting&gt;

 &lt;!--继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID匹配到这里的依赖，并使用这里的依赖信息。--&gt; 

 &lt;dependencyManagement&gt;

  &lt;dependencies&gt;

   &lt;!--参见dependencies/dependency元素--&gt;

   &lt;dependency&gt;

    ......

   &lt;/dependency&gt;

  &lt;/dependencies&gt;

 &lt;/dependencyManagement&gt;    

    &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。--&gt;  

    &lt;distributionManagement&gt;

        &lt;!--部署项目产生的构件到远程仓库需要的信息--&gt;

        &lt;repository&gt;

         &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素--&gt;

   &lt;uniqueVersion/&gt;

   &lt;id&gt;banseon-maven2&lt;/id&gt;  

   &lt;name&gt;banseon maven2&lt;/name&gt;  

            &lt;url&gt;file://${basedir}/target/deploy&lt;/url&gt;  

            &lt;layout/&gt;

  &lt;/repository&gt;

  &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素--&gt;  

  &lt;snapshotRepository&gt;

   &lt;uniqueVersion/&gt;

   &lt;id&gt;banseon-maven2&lt;/id&gt; 

            &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; 

            &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;  

   &lt;layout/&gt;

  &lt;/snapshotRepository&gt;

  &lt;!--部署项目的网站需要的信息--&gt;  

        &lt;site&gt;

         &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置--&gt;  

            &lt;id&gt;banseon-site&lt;/id&gt;  

            &lt;!--部署位置的名称--&gt;

            &lt;name&gt;business api website&lt;/name&gt;  

            &lt;!--部署位置的URL，按protocol://hostname/path形式--&gt;

            &lt;url&gt;  

                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web   

            &lt;/url&gt;  

        &lt;/site&gt;

  &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。--&gt;

  &lt;downloadUrl/&gt;

  &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。--&gt;

  &lt;relocation&gt;

   &lt;!--构件新的group ID--&gt;

   &lt;groupId/&gt;

   &lt;!--构件新的artifact ID--&gt;

   &lt;artifactId/&gt;

   &lt;!--构件新的版本号--&gt;

   &lt;version/&gt;

   &lt;!--显示给用户的，关于移动的额外信息，例如原因。--&gt;

   &lt;message/&gt;

  &lt;/relocation&gt;

  &lt;!--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。--&gt;

  &lt;status/&gt;        

    &lt;/distributionManagement&gt;

    &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。--&gt;

    &lt;properties/&gt;

&lt;/project&gt;

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《深入理解Java虚拟机》· 自动内存管理机制]]></title>
    <link href="https://lorch.github.io/14767145794378.html"/>
    <updated>2016-10-17T22:29:39+08:00</updated>
    <id>https://lorch.github.io/14767145794378.html</id>
    <content type="html"><![CDATA[
<ul>
<li><p>所有线程共享数据区：<code>方法区（Method Area/ no-heap）</code> <code>堆（Heap）</code></p></li>
<li><p>线程隔离的数据区：<code>虚拟机栈（VM Stack）</code> <code>本地方法栈（Native Method Stack）</code> <code>程序计数器（Program Counter Register）</code></p></li>
<li><p>heap区又分：<code>Eden Space（伊甸园）</code> <code>Survivor Space(幸存者区)</code> <code>Tenured Gen（老年代-养老区）</code></p></li>
<li><p>非heap区又分：<code>Code Cache(代码缓存区)</code> <code>Perm Gen（永久代）</code> <code>Jvm Stack(java虚拟机栈)</code> <code>Local Method Statck(本地方法栈)</code></p></li>
</ul>

<h2 id="toc_0">运行时区域数据</h2>

<h3 id="toc_1">程序计数器</h3>

<p>可以看做是当前线程所执行的字节码的行号指示器。<br/>
举例来说：<br/>
当一个线程正在执行一个Java方法 -&gt; 计数器记录正在执行的虚拟机字节码指令的地址<br/><br/>
当一个线程正在执行一个Native方法 -&gt; 计数器的值为空(Undefined)</p>

<blockquote>
<p>Java虚拟机的多线程通过 线程轮流切换 并 分配处理器执行时间 的方式来实现</p>
</blockquote>

<h3 id="toc_2">Java虚拟机栈</h3>

<p>描述Java方法执行的内存模型：每个方法在执行时都会创建一个<code>栈帧 Stack Frame</code>，用于存储 <code>局部变量表</code> <code>操作数栈</code> <code>动态链接</code> <code>方法出口</code> <code>...</code> 。每一个方法从调用执行执行完成的过程，就对应着一个<code>栈帧</code>在虚拟机中入栈到出栈的过程。</p>

<p>该区域的两种异常：<br/>
<code>StackOverflowError</code>：线程请求的栈深度大于虚拟机所允许的深度。<br/>
<code>OutOfMemoryError</code>：虚拟机可以动态扩展，如果扩展时无法申请到足够多的内存。</p>

<blockquote>
<p>其与线程的生命周期相同</p>
</blockquote>

<h3 id="toc_3">局部变量表</h3>

<p>存放 <em>编译期</em> 可知的 基本数据类型(<code>boolean</code> <code>byte</code> <code>char</code> <code>short</code> <code>int</code> <code>float</code> <code>long</code> <code>double</code>)、对象引用(<code>reference</code>)、 returnAddress类型(指向一条字节码指令的地址)</p>

<h3 id="toc_4">本地方法栈</h3>

<p>与虚拟机的作用非常相似，虚拟机为虚拟机执行Java服务，本地方法栈为虚拟机使用Nativ服务。</p>

<h3 id="toc_5">Java 堆 [GC 堆]</h3>

<p>Java虚拟规范中描述：所有的对象实例以及数组都要在堆上分配。 —— 目前来说这种情况并非绝对。</p>

<h3 id="toc_6">方法区</h3>

<p>用于存储已被虚拟机加载的 <code>类信息</code> <code>常亮</code> <code>静态变量</code> <code>即时编译器编译后的代码</code> <code>...</code></p>

<h3 id="toc_7">运行常量池 [Runtime Constant Pool]</h3>

<p>用于存放编译期生成的各种 <code>字面量</code> 和 <code>符号引用</code>。</p>

<hr/>

<h2 id="toc_8">HotSpot 虚拟机对象探秘</h2>

<h3 id="toc_9">对象的内存布局</h3>

<p>对象在内存中存储的布局可以分为3块区域： <code>对象头 Header</code> <code>实例数据 Instance Data</code> <code>对齐填充 Padding</code></p>

<blockquote>
<ul>
<li>对象头包括两部分信息：</li>
<li>存储对象自身的运行时数据</li>
<li>类型指针</li>
</ul>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《深入理解Java虚拟机》· 高效并发]]></title>
    <link href="https://lorch.github.io/14767145277948.html"/>
    <updated>2016-10-17T22:28:47+08:00</updated>
    <id>https://lorch.github.io/14767145277948.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">this引用逃逸</h2>

<p>是指在构造函数返回之前其他线程就持有该对象的引用.调用尚未构造完全的对象的方法可能引发令人疑惑的错误, 因此应该避免this逃逸的发生.</p>

<h2 id="toc_1">内存态和引用态</h2>

<p>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态 和 内核态</p>

<ul>
<li><p>内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡.CPU也可以将自己从一个程序切换到另一个程序</p></li>
<li><p>用户态: 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取</p></li>
</ul>

<h2 id="toc_2">系统调用</h2>

<blockquote>
<p>所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等.<br/>
而唯一可以做这些事情的就是操作系统,所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.<br/>
这时需要一个这样的机制: 用户态程序切换到内核态,但是不能控制在内核态中执行的指令这种机制叫系统调用, 在CPU中的实现称之为陷阱指令(Trap Instruction)</p>
</blockquote>

<p><strong>他们的工作流程如下：</strong></p>

<ul>
<li>用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame),以此表明需要操作系统提供的服务.</li>
<li>用户态程序执行陷阱指令</li>
<li>CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问</li>
<li>这些指令称之为陷阱(trap)或者系统调用处理器(system call handler).他们会读取程序放入内存的数据参数, 并执行程序请求的服务</li>
<li>系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果</li>
</ul>

]]></content>
  </entry>
  
</feed>
